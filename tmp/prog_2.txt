Punto 1: Modellazione del Problema

Richiesta: "Write a Minizinc program that solves the problem... finding the plan of minimum length that sorts the vector."

Ho implementato questo nel file sorting.mzn.

    Definizione dello Stato (Righe 11-12):

        Codice: array[0..k, 1..n] of var int: v;

        Perché: Il problema richiede di trovare un piano, ovvero una sequenza di cambiamenti. Non basta avere il vettore iniziale e finale. Ho creato una matrice dove la riga 0 è l'inizio, la riga k è la fine, e le righe intermedie sono gli stati dopo ogni swap.

    Definizione delle Mosse (Righe 12):

        Codice: array[0..k-1] of var 1..n: idx1; e idx2

        Perché: Per ogni passo temporale t, dobbiamo decidere quali due indici scambiare. Queste sono le vere "variabili decisionali" che il solver deve scegliere.

    Vincolo di Swap (Righe 15-16):

        Codice: v[t+1, idx1[t]] = v[t, idx2[t]] /\ v[t+1, idx2[t]] = v[t, idx1[t]]

        Perché: Implementa l'operazione swap(i,j) richiesta dal testo, scambiando i valori nelle celle indicate.

    Frame Axiom (Riga 15-16, blocco forall):

        Codice: forall(p ... where p != idx1[t] ... ) ( v[t+1, p] = v[t, p] )

        Perché: Questo è fondamentale per la correttezza. Senza questa riga, MiniZinc "inventerebbe" valori per le celle che non stiamo toccando. Dobbiamo dire esplicitamente che "tutto ciò che non viene scambiato rimane uguale".

    Obiettivo Ordinamento (Riga 14):

        Codice: constraint forall(p in 1..n-1) (v[k, p] <= v[k, p+1]);

        Perché: Definisce la condizione di vittoria: al passo finale k, il vettore deve essere ordinato in modo crescente.

Punto 2: Generazione dei Benchmark

Richiesta: "Prepare your benchmark suite as follows. For n=5,10,15,20,25,30... compute 10 different permutations... You have now 60 instance benchmarks."

Ho implementato questo nel file benchmark.py.

    Generazione Istanze (Funzione generate_benchmarks, Righe 70-76):

        Codice:
        Python

sizes = [5, 10, 15, 20, 25, 30]
for n in sizes:
    for _ in range(10):
        vec = list(range(1, n + 1))
        random.shuffle(vec)

Perché: Questo ciclo crea esattamente le combinazioni richieste. random.shuffle garantisce che le permutazioni siano casuali e diverse tra loro, come richiesto dal testo ("randomly generate... 10 different permutations" ).

Punto 3: Esecuzione e Ricerca del Piano Minimo

Richiesta: "Run your Minizinc encoding on all the instances... with a timeout of 5 minutes... finding the plan of minimum length".

Ho implementato questo nel file benchmark.py.

    Ricerca del Minimo k (Funzione solve_sorting_instance, Righe 20-53):

        Codice:
        Python

k = 1
while not found:
    # ... solve ...
    if UNSATISFIABLE: k += 1

Perché: MiniZinc è eccellente nel verificare se una soluzione esiste per una lunghezza fissa, ma meno efficiente nel trovarla dinamicamente. Lo script Python parte da k=1 (1 mossa) e sale. Appena trova SATISFIED, abbiamo la garanzia matematica che quel k è la lunghezza minima possibile, soddisfacendo la richiesta "minimum length".

Timeout (Righe 9 e 39):

    Codice: TIMEOUT_SEC = 300 e timeout=timedelta(seconds=TIMEOUT_SEC)

    Perché: Applica rigorosamente il vincolo "timeout of 5 minutes for each test" richiesto dal testo.

Punto 4: Strategie di Ricerca Alternative

Richiesta: "Choose one configuration... try alternative search primitives on it. Use the most promising one for more difficult instances."

Ho implementato questo nei file sorting_template.mzn e benchmark_strategies.py.

    Il Template (File sorting_template.mzn, Riga 8):

        Codice: {{SOLVE_STRATEGY}}

        Perché: Il testo chiede di confrontare primitive di ricerca diverse. Invece di riscrivere il file MiniZinc a mano ogni volta, ho creato un "segnaposto". Python inietterà la strategia qui.

    Definizione delle Strategie (File benchmark_strategies.py, Righe 13-26):

        Codice:
        Python

STRATEGIES = {
    "2. Moves_FirstFail": "solve :: int_search(all_moves, first_fail, ...)",
    "3. Moves_InputOrder": "solve :: int_search(all_moves, input_order, ...)"
}

Perché: Qui definisco le "alternative search primitives" richieste.

        first_fail: Ordina al solver di tentare prima le variabili più critiche (quelle con meno opzioni o che falliscono prima). È la strategia "promettente" per le istanze difficili.

        input_order: Ordina al solver di andare in ordine cieco. Serve come termine di paragone per dimostrare il miglioramento.

Confronto sulle Istanze Difficili (File benchmark_strategies.py, Loop principale):

    Perché: Lo script esegue entrambe le strategie sugli stessi dati e stampa i tempi. Questo ti fornisce i dati empirici per dire: "La strategia First Fail è X volte più veloce", rispondendo alla richiesta di usare la più promettente.

In sintesi per la tua relazione:

Hai creato un sistema ibrido Python + MiniZinc.

    MiniZinc garantisce la correttezza logica (swap, ordinamento).

    Python gestisce la complessità dell'ottimizzazione (trovare il k minimo iterando) e la sperimentazione scientifica (generare i dati, cambiare le euristiche di ricerca al volo e misurare i tempi).