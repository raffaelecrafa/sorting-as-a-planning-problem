\section{The Benchmark Engine: \texttt{benchmark.py}}

MiniZinc solves problems for a \textbf{fixed} horizon $k$. To find the \textit{minimum} $k$, we need an external controller. The script \texttt{benchmark.py} acts as a \textbf{meta-solver} implementing Iterative Deepening with intelligent lower bound computation.

\subsection{Benchmark Suite Generation}

Following the project specification, we generate 60 benchmark instances:

\begin{lstlisting}[language=Python]
def generate_benchmarks():
    benchmarks = []
    sizes = [5, 10, 15, 20, 25, 30]  # As per specification
    for n in sizes:
        for _ in range(10):  # 10 permutations per size
            vec = list(range(1, n + 1))
            random.shuffle(vec)
            benchmarks.append((n, vec))
    return benchmarks
\end{lstlisting}

This produces:
\begin{itemize}
    \item 10 instances for $N=5$ (instances 1--10)
    \item 10 instances for $N=10$ (instances 11--20)
    \item 10 instances for $N=15$ (instances 21--30)
    \item 10 instances for $N=20$ (instances 31--40)
    \item 10 instances for $N=25$ (instances 41--50)
    \item 10 instances for $N=30$ (instances 51--60)
\end{itemize}

\subsection{Optimization: Smart Lower Bound Starting Point}

To accelerate solving, instead of starting iterative deepening from $k=1$, we employ an optimization technique based on cycle decomposition to compute an intelligent starting point. This avoids wasting iterations on values of $k$ that are provably too small.

\paragraph{The Lower Bound Formula.} Every permutation can be decomposed into disjoint cycles. The minimum number of moves needed to sort a permutation is given by:
\begin{equation}
    k_{\min} = n - c
\end{equation}
where $n$ is the length of the permutation and $c$ is the number of disjoint cycles. This bound is fundamental: a cycle of length $\ell$ requires exactly $\ell - 1$ swaps to resolve. Since there are $c$ cycles in total, and the sum of their lengths is $n$, the total number of swaps is $\sum_{i=1}^{c}(\ell_i - 1) = n - c$.

The implementation computes this lower bound as follows:

\begin{lstlisting}[language=Python]
def count_cycles(perm):
    n = len(perm)
    visited = [False] * n
    num_cycles = 0
    for i in range(n):
        if not visited[i]:
            num_cycles += 1
            j = i
            while not visited[j]:
                visited[j] = True
                j = perm[j] - 1  # Follow the cycle
    return num_cycles

def compute_starting_k(perm):
    n = len(perm)
    num_cycles = count_cycles(perm)
    k_min = n - num_cycles  # Lower bound from cycle decomposition

    # Parity correction
    initial_inv = count_inversions(perm)
    if (k_min % 2) != (initial_inv % 2):
        k_min += 1
    return k_min
\end{lstlisting}

The parity correction ensures consistency with the Parity Invariant constraint (Section 2.3): every swap changes the parity of the permutation, so the number of swaps must have the same parity as the initial number of inversions.

This optimization allows the iterative deepening loop to begin searching near the actual optimum rather than from $k=1$, providing dramatic speedups especially for larger instances.

\subsection{Iterative Deepening with Intelligent Start}

\begin{lstlisting}[language=Python]
def solve_sorting_instance(model, solver, n, start_v):
    # Start from theoretical lower bound, not k=1
    k = compute_starting_k(start_v)

    while not found:
        instance = minizinc.Instance(solver, model)
        instance["n"] = n
        instance["start_v"] = start_v
        instance["k"] = k

        result = instance.solve(timeout=timedelta(seconds=300))

        if result.status == minizinc.Status.SATISFIED:
            return k, result  # Found optimal!
        elif result.status == minizinc.Status.UNSATISFIABLE:
            k += 1  # Try longer plan
\end{lstlisting}

\textbf{Optimization impact:} For $N=30$, a random permutation typically has $k_{\min} \approx 25$. Without cycle decomposition, the solver would waste time on 24 UNSAT iterations. With it, we often find the solution on the first attempt.

\subsection{Output Format}

Results are saved to individual text files in \texttt{result\_benchmark/}:
\begin{lstlisting}[language=Python]
def save_result_to_file(index, n, vec, k, time_taken, result):
    filename = f"result_{index:02d}_N{n}.txt"
    # Writes: dimension, input vector, K found, time, plan steps
\end{lstlisting}

Each file contains the complete solution trace, including every swap performed and the resulting intermediate states.