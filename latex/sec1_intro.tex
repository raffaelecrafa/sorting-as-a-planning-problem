\section{Introduction}

This project addresses \textbf{Project 5: Sorting as a Planning Problem}. Given a vector $\vec{v} = [v_1, \ldots, v_n]$ representing a permutation of integers $\{1, \ldots, n\}$, the objective is to find the \textbf{minimum number of pairwise swaps} required to sort it in ascending order.

A \texttt{swap(i, j)} operation exchanges the values at positions $i$ and $j$: after the swap, $v[i]$ and $v[j]$ are interchanged. The problem asks for the \textbf{minimum length plan}—the shortest sequence of swaps—that transforms the initial permutation into the sorted sequence $[1, 2, \ldots, n]$.

\subsection{Problem Formalization}

The problem can be formally stated as follows:
\begin{itemize}
    \item \textbf{Input:} A permutation $\vec{v} = [v_1, \ldots, v_n]$ of integers from $1$ to $n$.
    \item \textbf{Output:} A sequence of swaps $\langle \text{swap}(i_1, j_1), \text{swap}(i_2, j_2), \ldots, \text{swap}(i_k, j_k) \rangle$ of minimum length $k$ such that applying these swaps in order produces the sorted sequence $[1, 2, \ldots, n]$.
\end{itemize}

\paragraph{Example}

Consider the permutation $\vec{v} = [2, 3, 1, 5, 4]$ of size $n=5$:
\begin{itemize}
    \item \textbf{Initial state:} $[2, 3, 1, 5, 4]$
    \item \textbf{Step 1:} $\text{swap}(1, 2)$ $\rightarrow$ $[3, 2, 1, 5, 4]$ (swap positions 1 and 2)
    \item \textbf{Step 2:} $\text{swap}(1, 3)$ $\rightarrow$ $[1, 2, 3, 5, 4]$ (swap positions 1 and 3)
    \item \textbf{Step 3:} $\text{swap}(4, 5)$ $\rightarrow$ $[1, 2, 3, 4, 5]$ (swap positions 4 and 5)
\end{itemize}
The minimum plan length is $k=3$. No sequence of fewer than 3 swaps can sort this permutation.

\subsection{Sorting as a Planning Problem}

This problem naturally maps to a \textbf{discrete planning problem}:
\begin{itemize}
    \item \textbf{State:} The current configuration of the vector at each timestep $t$.
    \item \textbf{Action:} A swap operation $\text{swap}(i, j)$ that modifies the state.
    \item \textbf{Initial State:} The input permutation $\vec{v}$.
    \item \textbf{Goal State:} The sorted sequence $[1, 2, \ldots, n]$.
    \item \textbf{Horizon:} The number of timesteps $k$ (plan length).
\end{itemize}

The problem is modeled as a \textbf{Constraint Satisfaction Problem (CSP)} where, for a fixed horizon $k$, the solver must determine whether a valid plan exists. The minimum $k$ is found via \textbf{Iterative Deepening}: we start with $k=k_{\min}$ (a lower bound computed from cycle decomposition) and increment $k$ until a satisfiable solution is found.

\subsection{Project Structure}

The project implementation is distributed across five files:
\begin{enumerate}
    \item \textbf{\texttt{sorting.mzn}}: The core MiniZinc model defining variables, constraints, and the search strategy for a fixed horizon $k$.
    \item \textbf{\texttt{benchmark.py}}: A Python meta-solver implementing Iterative Deepening with cycle-based lower bound computation.
    \item \textbf{\texttt{sorting\_template.mzn}}: An extended version of the base model with a placeholder for dynamic strategy injection.
    \item \textbf{\texttt{benchmark\_strategies.py}}: The experimental suite for comparing 12 different search heuristics.
    \item \textbf{\texttt{plot.py}}: A visualization script for graphical analysis of benchmark results.
\end{enumerate}

